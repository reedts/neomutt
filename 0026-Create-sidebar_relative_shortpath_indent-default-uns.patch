From b09a0b8068afeb55f2cff6936f127dcffd4ab231 Mon Sep 17 00:00:00 2001
From: Kevin McCarthy <kevin@8t8.us>
Date: Sat, 7 Dec 2019 13:21:49 -0800
Subject: Create $sidebar_relative_shortpath_indent, default unset

When unset this option provides the pre-1.13.0 sidebar indentation and
shortpath behavior.

Setting the option will enable the new (relative to previous entries)
indentation and shortening behavior.

Note the mailbox shortcuts are controlled by
$sidebar_use_mb_shortcuts, which defaults set.

Upstream-commit: https://gitlab.com/muttmua/mutt/commit/b09a0b8068afeb55f2cff6936f127dcffd4ab231
Co-authored-by: Richard Russon <rich@flatcap.org>
---
 init.h    | 28 ++++++++++++++++++++++
 mutt.h    |  1 +
 sidebar.c | 72 +++++++++++++++++++++++++++++++++----------------------
 3 files changed, 73 insertions(+), 28 deletions(-)

diff --git a/init.h b/init.h
index 87793686..c7dc59db 100644
--- a/init.h
+++ b/init.h
@@ -3272,6 +3272,34 @@ struct option_t MuttVars[] = {
   ** \fC<sidebar-prev-new>\fP command is similarly affected, wrapping around to
   ** the end of the list.
   */
+  { "sidebar_relative_shortpath_indent", DT_BOOL, R_SIDEBAR, {.l=OPTSIDEBARRELSPINDENT}, {.l=0} },
+  /*
+  ** .pp
+  ** When set, this option changes how $$sidebar_short_path and
+  ** $$sidebar_folder_indent perform shortening and indentation: both
+  ** will look at the previous sidebar entries and shorten/indent
+  ** relative to the most recent parent.
+  ** .pp
+  ** An example of this option set/unset for mailboxes listed in this
+  ** order, with $$sidebar_short_path=yes,
+  ** $$sidebar_folder_indent=yes, and $$sidebar_indent_string="→":
+  ** .dl
+  ** .dt \fBmailbox\fP  .dd \fBset\fP   .dd \fBunset\fP
+  ** .dt \fC=a.b\fP     .dd \fC=a.b\fP  .dd \fC→b\fP
+  ** .dt \fC=a.b.c.d\fP .dd \fC→c.d\fP  .dd \fC→→→d\fP
+  ** .dt \fC=a.b.e\fP   .dd \fC→e\fP    .dd \fC→→e\fP
+  ** .de
+  ** .pp
+  ** The second line illustrates most clearly.  With this option set,
+  ** \fC=a.b.c.d\fP is shortened relative to \fC=a.b\fP, becoming
+  ** \fCc.d\fP; it is also indented one place relative to \fC=a.b\fP.
+  ** With this option unset \fC=a.b.c.d\fP is always shortened to the
+  ** last part of the mailbox, \fCd\fP and is indented three places,
+  ** with respect to $$folder (represented by '=').
+  ** .pp
+  ** When set, the third line will also be indented and shortened
+  ** relative to the first line.
+  */
   { "sidebar_short_path", DT_BOOL, R_SIDEBAR, {.l=OPTSIDEBARSHORTPATH}, {.l=0} },
   /*
   ** .pp
diff --git a/mutt.h b/mutt.h
index de039c92..e068b7e6 100644
--- a/mutt.h
+++ b/mutt.h
@@ -515,6 +515,7 @@ enum
   OPTSIDEBARFOLDERINDENT,
   OPTSIDEBARNEWMAILONLY,
   OPTSIDEBARNEXTNEWWRAP,
+  OPTSIDEBARRELSPINDENT,
   OPTSIDEBARUSEMBSHORTCUTS,
   OPTSIDEBARSHORTPATH,
 #endif
diff --git a/sidebar.c b/sidebar.c
index ceb6c605..e4c258fc 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -619,6 +619,7 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
   int entryidx;
   SBENTRY *entry;
   BUFFY *b;
+  int maildir_is_prefix;
   int indent_width = -1;
   int indent_depths[SIDEBAR_MAX_INDENT];
   const char *sidebar_folder_name;
@@ -668,11 +669,14 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
       b->msg_flagged = Context->flagged;
     }
 
+    maildir_is_prefix = 0;
     if (option (OPTSIDEBARUSEMBSHORTCUTS))
     {
       mutt_buffer_strcpy (pretty_folder_name, mutt_b2s (b->pathbuf));
       mutt_buffer_pretty_mailbox (pretty_folder_name);
       sidebar_folder_name = mutt_b2s (pretty_folder_name);
+      if (sidebar_folder_name[0] == '=')
+        maildir_is_prefix = 1;
     }
     else
     {
@@ -688,7 +692,10 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
           (mutt_strncmp (Maildir, mutt_b2s (b->pathbuf), maildirlen) == 0) &&
           SidebarDelimChars &&
           strchr (SidebarDelimChars, mutt_b2s (b->pathbuf)[maildirlen]))
+      {
         sidebar_folder_name = mutt_b2s (b->pathbuf) + (maildirlen + 1);
+        maildir_is_prefix = 1;
+      }
       else
         sidebar_folder_name = mutt_b2s (b->pathbuf);
     }
@@ -704,34 +711,43 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
 
         calculate_depth (sidebar_folder_name, mutt_b2s (last_folder_name),
                          &depth, &common_depth);
-        mutt_buffer_strcpy (last_folder_name, sidebar_folder_name);
-
-        if (indent_width < SIDEBAR_MAX_INDENT)
-          indent_width++;
-
-        /* indent_depths[] hold the path depths at each level of indentation.
-         * Indent based off the longest path that we share in common.
-         *
-         * The 'indent_depths[] >= depth' test below is for a corner case:
-         *
-         * path       depth    common_depth    indent_width
-         * /a           2            0              0
-         * /a/b         3            2              1
-         * /a/b/        3            3              1
-         *
-         * Because the common_depth of /a/b/ matches the depth of
-         * /a/b, we need the additional test to continue popping the
-         * indent_depths[] stack.
-         */
-        while (indent_width &&
-               ((indent_depths[indent_width - 1] > common_depth) ||
-                (indent_depths[indent_width - 1] >= depth)))
-          indent_width--;
-
-        if (indent_width < SIDEBAR_MAX_INDENT)
-          indent_depths[indent_width] = depth;
-        if (indent_width)
-          parent_depth = indent_depths[indent_width - 1];
+
+        if (option(OPTSIDEBARRELSPINDENT))
+        {
+          mutt_buffer_strcpy (last_folder_name, sidebar_folder_name);
+
+          if (indent_width < SIDEBAR_MAX_INDENT)
+            indent_width++;
+
+          /* indent_depths[] hold the path depths at each level of indentation.
+           * Indent based off the longest path that we share in common.
+           *
+           * The 'indent_depths[] >= depth' test below is for a corner case:
+           *
+           * path       depth    common_depth    indent_width
+           * /a           2            0              0
+           * /a/b         3            2              1
+           * /a/b/        3            3              1
+           *
+           * Because the common_depth of /a/b/ matches the depth of
+           * /a/b, we need the additional test to continue popping the
+           * indent_depths[] stack.
+           */
+          while (indent_width &&
+                 ((indent_depths[indent_width - 1] > common_depth) ||
+                  (indent_depths[indent_width - 1] >= depth)))
+            indent_width--;
+
+          if (indent_width < SIDEBAR_MAX_INDENT)
+            indent_depths[indent_width] = depth;
+          if (indent_width)
+            parent_depth = indent_depths[indent_width - 1];
+        }
+        else
+        {
+          parent_depth = depth - 1;
+          indent_width = maildir_is_prefix ? depth - 1 : 0;
+        }
       }
 
       if (option (OPTSIDEBARSHORTPATH) && parent_depth)
-- 
2.24.1

